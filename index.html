<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Gooooood</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Android 客户端">
<meta property="og:type" content="website">
<meta property="og:title" content="Gooooood">
<meta property="og:url" content="http://zhaoshuo.me/index.html">
<meta property="og:site_name" content="Gooooood">
<meta property="og:description" content="Android 客户端">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gooooood">
<meta name="twitter:description" content="Android 客户端">
  
    <link rel="alternative" href="/atom.xml" title="Gooooood" type="application/atom+xml">
  
  
    <link rel="icon" href="/blackcat.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://zhaoshuo.me/img/blackcat.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Gooooood</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/随笔">随笔</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/thesingularityisnear" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://www.jianshu.com/users/126f0e4a7246/latest_articles" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:gandroid@yeah.net" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/AsyncStorage/" style="font-size: 10px;">AsyncStorage</a> <a href="/tags/Class/" style="font-size: 10px;">Class</a> <a href="/tags/GC算法/" style="font-size: 10px;">GC算法</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/IPC/" style="font-size: 10px;">IPC</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/React-Native/" style="font-size: 13.33px;">React Native</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/VPN/" style="font-size: 10px;">VPN</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/内存/" style="font-size: 13.33px;">内存</a> <a href="/tags/内存回收/" style="font-size: 10px;">内存回收</a> <a href="/tags/内存管理/" style="font-size: 10px;">内存管理</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/教程/" style="font-size: 13.33px;">教程</a> <a href="/tags/歌词/" style="font-size: 10px;">歌词</a> <a href="/tags/版本管理/" style="font-size: 10px;">版本管理</a> <a href="/tags/科学上网/" style="font-size: 10px;">科学上网</a> <a href="/tags/类加载/" style="font-size: 10px;">类加载</a> <a href="/tags/虚拟机/" style="font-size: 20px;">虚拟机</a> <a href="/tags/资源加载/" style="font-size: 10px;">资源加载</a> <a href="/tags/进程间通信/" style="font-size: 10px;">进程间通信</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/126f0e4a7246/timeline">简书主页</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/thesingularityisnear">CSDN主页</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">坐标帝都，专注于Android客户端开发</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Gooooood</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://zhaoshuo.me/img/blackcat.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Gooooood</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/thesingularityisnear" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://www.jianshu.com/users/126f0e4a7246/latest_articles" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:gandroid@yeah.net" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-ReactNative数据存储" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/29/ReactNative数据存储/" class="article-date">
  	<time datetime="2016-07-29T06:38:11.000Z" itemprop="datePublished">2016-07-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/29/ReactNative数据存储/">ReactNative数据存储</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RN使用AsyncStore将数据存储到本地，AsyncStorage是一个基于key-value键值对的异步持久化存储系统，对于应用来说其存储的内容全局生效。</p>
<p>AsyncStorage使用异步<a href="http://www.infoq.com/cn/news/2011/09/js-promise" target="_blank" rel="external">Promise</a>模式存储数据，例如调用存储方法存储一个字符串<code>setItem(&#39;I_AM_KEY&#39;,&#39;i_am_value&#39;)</code>，<code>setItem</code>会异步执行，等<code>setItem</code>执行完成后会返回一个Promise对象。</p>
<p>举个例子：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">import React,&#123;AsyncStorage,Component,TouchableOpacity,View,Text，AppRegistry&#125; from <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 数据对应的key</span><br><span class="line">var STORAGE_KEY = <span class="string">'I_AM_KEY'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> 获取</span><br><span class="line">    async _get() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Demo._get()'</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="regexp">//</span> <span class="keyword">try</span> <span class="keyword">catch</span> 捕获异步执行的异常</span><br><span class="line">            var value = await AsyncStorage.getItem(STORAGE_KEY);</span><br><span class="line">            <span class="keyword">if</span> (value !== <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'_get() success: '</span> ,value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'_get() no data'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'_get() error: '</span>,error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> 保存</span><br><span class="line">    async _save(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Demo._save()'</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            await AsyncStorage.setItem(STORAGE_KEY, value);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'_save success: '</span>,value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'_save error: '</span>,error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> 删除</span><br><span class="line">    async _remove() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Demo._remove()'</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            await AsyncStorage.removeItem(STORAGE_KEY);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'_remove() success'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'_remove() error: '</span>, error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">              &lt;View style=&#123;&#123;<span class="attribute">flexDirection</span>:<span class="string">'column'</span>,<span class="attribute">flex</span>:<span class="number">1</span>,<span class="attribute">marginTop</span>:<span class="number">50</span>,&#125;&#125;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;TouchableOpacity  style=&#123;&#123;<span class="attribute">padding</span>:<span class="number">10</span>,<span class="attribute">flex</span>:<span class="number">1</span>,<span class="attribute">flexDirection</span>:<span class="string">'row'</span>,&#125;&#125; onPress=&#123;()=&gt;<span class="keyword">this</span>._save(<span class="string">'haha'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'you can do something here when the setItem is starting'</span>)).done(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'you can do something here when the setItem is done'</span>));&#125;&gt;</span><br><span class="line">                    &lt;Text style=&#123;&#123;<span class="attribute">fontSize</span>:<span class="number">16</span>,<span class="attribute">color</span>:<span class="string">'#333333'</span>&#125;&#125;&gt;保存数据&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">                &lt;TouchableOpacity  style=&#123;&#123;<span class="attribute">padding</span>:<span class="number">10</span>,<span class="attribute">flex</span>:<span class="number">1</span>,<span class="attribute">flexDirection</span>:<span class="string">'row'</span>,&#125;&#125; onPress=&#123;()=&gt;<span class="keyword">this</span>._get().done()&#125;&gt;</span><br><span class="line">                    &lt;Text style=&#123;&#123;<span class="attribute">fontSize</span>:<span class="number">16</span>,<span class="attribute">color</span>:<span class="string">'#333333'</span>&#125;&#125;&gt;获取数据&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">                &lt;TouchableOpacity  style=&#123;&#123;<span class="attribute">padding</span>:<span class="number">10</span>,<span class="attribute">flex</span>:<span class="number">1</span>,<span class="attribute">flexDirection</span>:<span class="string">'row'</span>,&#125;&#125; onPress=&#123;()=&gt;<span class="keyword">this</span>._remove()&#125;&gt;</span><br><span class="line">                    &lt;Text style=&#123;&#123;<span class="attribute">fontSize</span>:<span class="number">16</span>,<span class="attribute">color</span>:<span class="string">'#333333'</span>&#125;&#125;&gt;删除数据&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">              &lt;/View&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'Demo'</span>, <span class="function"><span class="params">()</span> =&gt;</span> Demo);</span><br></pre></td></tr></table></figure>
<p>代码很简单，点击三个按钮就可以看到console控制台的输出数据。</p>
<p>ES6中promise提供了几个回调方法then，done，finally，如下所示：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._save(<span class="string">'haha'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'you can do something here when the setItem is starting'</span>)).done(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'you can do something here when the setItem is done'</span>));</span><br></pre></td></tr></table></figure></p>
<ul>
<li>then()方法会在setItem开始执行后执行</li>
<li>done()方法会在setItem执行完成后调用，done<br>都会捕捉到任何可能出现的错误，并向全局抛出</li>
<li>finally则是回调链执行的最后一个方法</li>
</ul>
<p>AsyncStore全部方法列表参请参考<a href="http://reactnative.cn/docs/0.27/asyncstorage.html#content" target="_blank" rel="external">官方文档</a>，或者在你的工程项目中搜索AsyncStore.js查看源码。</p>
<hr>
<p>参考资料：</p>
<p><a href="http://reactnative.cn/docs/0.27/asyncstorage.html#content" target="_blank" rel="external">官方AsyncStore</a><br><a href="https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md" target="_blank" rel="external">React Native Storage第三方组件</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#两个有用的附加方法" target="_blank" rel="external">Promise的回调方法</a><br><a href="http://aisk.me/using-async-await-to-avoid-callback-hell/" target="_blank" rel="external">JavaScript ES7 中使用 async/await 解决回调函数嵌套问题</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AsyncStorage/">AsyncStorage</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-Native/">React Native</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/React-Native/">React Native</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java内存区域与异常" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/29/Java内存区域与异常/" class="article-date">
  	<time datetime="2016-07-29T04:15:51.000Z" itemprop="datePublished">2016-07-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/29/Java内存区域与异常/">Java内存区域与异常</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java虚拟机在运行时会把其管理的内存划分为若干不同的数据区域。《Java虚拟机规范》规定的数据区域通常包括程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区、运行时常量池以及直接内存。这些区域都会有各自不同的生存周期以及各自不同的用途，本文主要介绍这些内存区域以及各个内存区域可能抛出的异常。</p>
<h2 id="u7A0B_u5E8F_u8BA1_u6570_u5668"><a href="#u7A0B_u5E8F_u8BA1_u6570_u5668" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器相当于当前线程所执行字节码的行号指示器。字节码解释器通过改变这个计数器来选取下一条需要执行的字节码指令，程序的循环、跳转、异常处理、线程切换都需要依赖这个计数器来完成。</p>
<p>一个Java虚拟机内部可以有多个线程，每个线程都会有单独的程序计数器，程序计数器属于线程私有内存，各个计数器之间互不影响。</p>
<p>程序计数器记录的只能是Java方法编译出的字节码指令地址，对于Native方法，则计数器为空。程序计数器不会出现OutOfMemoryError异常。</p>
<h2 id="Java_u865A_u62DF_u673A_u6808"><a href="#Java_u865A_u62DF_u673A_u6808" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈就是我们经常说的堆栈中的栈内存。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>虚拟机栈中有一个局部变量表，局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和指向一条字节码指令地址的returnAddress类型。</p>
<p>虚拟机栈是线程私有的，其生命周期与线程相同。此区域可能会出现两种异常：如果请求栈深度大于虚拟机最大允许栈深度则抛出StackOverflowError异常；如果虚拟机栈在动态扩展时无法申请到足够的内存则会抛出OutOfMemoryError异常。</p>
<h2 id="u672C_u5730_u65B9_u6CD5_u6808"><a href="#u672C_u5730_u65B9_u6CD5_u6808" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>同Java虚拟机栈相似，本地方法栈是Native方法执行的内存模型，其内部也会抛出StackOverflowError和OutOfMemory异常。</p>
<h2 id="Java__u5806"><a href="#Java__u5806" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>Java堆用来存放虚拟机在运行时创建的Java对象实例。Java虚拟机规范规定：所有的对象实例以及数组都要在堆上分配。不过现在很多技术比如Just InTime（及时编译），允许在栈中分配对象内存。</p>
<p>Java堆内存被所有线程共享，任何线程都可以在上面创建对象。内存回收（GC）主要在Java堆上进行。</p>
<p>Java堆内存也是虚拟机所管理的内存最大的一块。其内存只要逻辑上连续即可，允许物理上不连续。如果在创建对象时堆内存没有足够的内存分配会抛出OutOfMemoryError异常。</p>
<h2 id="u65B9_u6CD5_u533A"><a href="#u65B9_u6CD5_u533A" class="headerlink" title="方法区"></a>方法区</h2><p>方法区用来存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据，被所有线程共享。</p>
<p>当方法区无法满足内存分配时，会抛出OutOfMemoryError异常。</p>
<h2 id="u8FD0_u884C_u65F6_u5E38_u91CF_u6C60"><a href="#u8FD0_u884C_u65F6_u5E38_u91CF_u6C60" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，Class文件中的常量池（Constant Pool Table）在类加载后会放到运行时常量池中。</p>
<p>Class常量池用于存放编译期生成的各种字面常量和符号引用。运行时常量池与Class常量池的区别就是动态性。运行时常量池不仅仅允许编译期放入常量池，也允许运行时将新的常量放入常量池。而Class常量池只能在编译期生成。Java虚拟机规范对Class常量池要求严格，对运行时常量池的要求则比较宽松。</p>
<p>当常量池无法再申请到内存空间时会抛出OutOfMemoryError异常。</p>
<h2 id="u76F4_u63A5_u5185_u5B58"><a href="#u76F4_u63A5_u5185_u5B58" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存也就是我们本机可用的物理内存空间，不属于任何Java虚拟机，但任何虚拟机都可以在上面操作。例如，Java虚拟机可以通过NIO包中提供的方法直接在物理内存中分配。</p>
<p>当Java虚拟机要求分配的内存大于本机物理内存时就会抛出OutOfMemoryError异常。</p>
<h2 id="u5185_u5B58_u6EA2_u51FA_u4E0E_u5185_u5B58_u6CC4_u9732_u7684_u533A_u522B"><a href="#u5185_u5B58_u6EA2_u51FA_u4E0E_u5185_u5B58_u6CC4_u9732_u7684_u533A_u522B" class="headerlink" title="内存溢出与内存泄露的区别"></a>内存溢出与内存泄露的区别</h2><p><strong>内存溢出</strong><br>内存溢出是指分配对象的内存超过虚拟机所允许的最大内存，此时所有的对象实例均有用。优化方案就是尝试减少程序运行时内存消耗。</p>
<p><strong>内存泄露</strong><br>某些对象不再有用，但由于不正确的引用关系造成对象内存无法释放，最终导致所有对象的内存超过虚拟机所允许的最大值。所以要检查每个对象的生命周期，确保长生命周期对象引用短生命周期时释放内存。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存/">内存</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异常/">异常</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟机/">虚拟机</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java虚拟机/">Java虚拟机</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-虚拟机类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/24/虚拟机类加载机制/" class="article-date">
  	<time datetime="2016-07-24T06:15:05.000Z" itemprop="datePublished">2016-07-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/24/虚拟机类加载机制/">虚拟机类加载机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成。虚拟机在运行期间会把描述类的数据从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机知己网使用的Java类型，这就是虚拟机的类加载机制。</p>
<h2 id="1_u3001_u7C7B_u52A0_u8F7D_u8FC7_u7A0B"><a href="#1_u3001_u7C7B_u52A0_u8F7D_u8FC7_u7A0B" class="headerlink" title="1、类加载过程"></a>1、类加载过程</h2><p>类从被加载到内存开始，到卸载出内存为止，其生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。</p>
<p><strong>1.1 加载</strong></p>
<p>虚拟机规范没有对类加载的时机做规定，但要求五种情况必须触发类初始化，而在类初始化之前必定会先被加载：</p>
<ol>
<li>创建一个类，调用类的静态方法静态变量时，如果类没有进行初始化，则需要先触发其初始化</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行初始化则需要先触发其初始化</li>
<li>初始化一个类时如果其父类还没有进行初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的类），虚拟机要先初始化这个类</li>
<li>当使用JDK1.7动态语言时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。</li>
</ol>
<p>虚拟机需要完成三件事：</p>
<ol>
<li>通过类得全限定名来获取定义此类额二进制字节流（可以从zip包读取，如JAR，WAR，可以从网络中获取，可以动态生成JSP，可以从数据库中读取）</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口</li>
</ol>
<p>加载阶段，既可以使用系统提供的引导类加载器来完成，又可以使用用户自定义的类加载器完成。</p>
<p><strong>1.2 验证</strong></p>
<p>验证是连接的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p>
<p>验证阶段包括4部分：</p>
<ol>
<li>文件格式校验，验证字节流是否符合Class文件格式规范，版本号是否可以被虚拟机接受等等</li>
<li>元数据校验，对字节码描述信息进行语义分析，以保证描述信息符合Java语言规范</li>
<li>字节码校验，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，保证程序方法在运行期间不会做出危害虚拟机的事</li>
<li>符号引用校验，在虚拟机将符号引用转化为直接引用时（引用类方法字段等）需要进行符号引用校验，可以看做是对类自身以外（常量池的各种符号引用）的信息进行匹配性校验，目的是确保解析动作能正常执行，如果无法通过符号引用验证则会抛出类似java.lang.IllegalAccessError，java.lang.NoSuchFieldError，java.lang.NoSuchMethodError等。</li>
</ol>
<p><strong>1.3 准备</strong></p>
<p>准备阶段为类变量（不包括实例变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>此处所设置的类变量初始值，并不是程序代码中所设置的初始值，而是为类变量赋0值，例如int类型为0，boolean类型为false。根据程序代码设置初始值是在初始化阶段发生。</p>
<p><strong>1.4 解析</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量（类接口，字段方法常量等），只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存。</p>
<p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</p>
<p><strong>1.5 初始化</strong></p>
<p>初始化是类加载过程的最后一步，从这里开始执行Java程序代码。在准备阶段变量已经赋值过一次系统要求的初始值，初始化阶段则是根据程序代码去初始化类变量，同一个类加载器下一个类只会被初始化一次。</p>
<h2 id="2_u3001_u7C7B_u52A0_u8F7D_u5668"><a href="#2_u3001_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="2、类加载器"></a>2、类加载器</h2><p>类加载器功能就是通过一个类的全限定名来获取描述此类的二进制字节流。Java允许程序自己去实现类加载器。当前自定义类加载器可以实现OSGI，热部署、代码加密等诸多功能。</p>
<p>Java中有两种类加载器，一种是启动类加载器（Bootstrap ClassLoader，使用C++实现）是虚拟机的一部分，另一种是其他类加载器，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。</p>
<ul>
<li><p>启动类加载器，负责将存放在<java_home>\lib目录中的类库加载到虚拟机内存中，无法被程序调用，用户编写自定义类加载器时如需把加载请求委派给引导类加载器直接使用null代替。</java_home></p>
</li>
<li><p>扩展类加载器（Extension ClassLoader），负责加载<java_home>\lib\ext目录中或者被java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></p>
</li>
<li><p>应用程序类加载器（Application ClassLoader），系统默认类加载器getSystemClassLoader()方法的返回值，负责加载用户（ClassPath）路径上所指定的类库，开发者可以直接使用这个类加载器</p>
</li>
</ul>
<p>类加载器中有一个概念是双亲委派模型，其工作过程：如果一个类加载器收到了加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需要的类）时，子加载器才会尝试自己去加载。</p>
<p>双亲委派模型有一个好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如，java.lang.Object，无论哪个类加载器加载最终都会交给最顶层的类加载器加载，因此Object在各种加载器环境中都是一个类（判断类是否相同，需要同一个类加载器加载的同一个Class文件，缺一不可）。</p>
<p>双亲委派模型并不是必须，当前很多JNDI，代码热部署，模块热部署的应用并不符合双亲委派模型原则的行为。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/类加载/">类加载</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟机/">虚拟机</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java虚拟机/">Java虚拟机</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Class类文件结构分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/23/Class类文件结构分析/" class="article-date">
  	<time datetime="2016-07-23T06:08:04.000Z" itemprop="datePublished">2016-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/23/Class类文件结构分析/">Class类文件结构分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Class文件中存储着Java虚拟机指令集和符号表以及若干辅助信息。它使用的是一种平台无关的字节码储存格式，不同的虚拟机实现都可以载入执行这种平台无关的字节码。Java虚拟机不与任何语言绑定，只与Class文件这种特定二进制文件格式关联，原则上任何语言都可以编译成Class文件在Java虚拟机上运行。</p>
<h2 id="1_u3001Class_u7C7B_u6587_u4EF6_u7ED3_u6784"><a href="#1_u3001Class_u7C7B_u6587_u4EF6_u7ED3_u6784" class="headerlink" title="1、Class类文件结构"></a>1、Class类文件结构</h2><p>Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p>
<p><strong>1.1 无符号数</strong></p>
<p>无符号数属于基本数据类型，以u1，u2，u4，u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<p><strong>1.2 表</strong></p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。Class中以_info结尾代表一张表。</p>
<h2 id="2_u3001Class_u5B57_u8282_u7801_u89E3_u6790"><a href="#2_u3001Class_u5B57_u8282_u7801_u89E3_u6790" class="headerlink" title="2、Class字节码解析"></a>2、Class字节码解析</h2><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格的按照顺序紧凑的排列在Class文件中。当遇到占用8字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。Class内部不包含任何分隔符，数据存储顺序数量都被严格限定，不允许任何改动。下面看看具体数据项的含义：</p>
<p><strong>2.1 魔数（Magic Number）</strong></p>
<p>每个Class文件的头4个字节称为魔数（Magic Number），它唯一作用就是用来确定文件是否能被虚拟机接受。</p>
<p>很多文件存储标准中都用魔数进行身份标识，如图片gif，jpeg都在文件头部中存储着魔数。使用魔数而不是用扩展名来进行识别主要是基于安全考虑，因为扩展名可以被随意改动。</p>
<p><strong>2.2 版本号</strong></p>
<p>接下来的4个字节存储着Class文件的版本号，第五第六个字节为次版本号（Minor Version），第七第八为主版本号（Major Version）。版本号主要用于版本控制，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<p><strong>2.3 常量池入口</strong></p>
<p>紧接着版本号之后的就是常量池入口，常量池入口后面还必须有一个u2数据项作为常量池容量计数器（因为常量池数量不固定）。</p>
<p>常量池是一个表类型的数据项，相当于Class文件的资源仓库，与Class文件其他项目关联最多，占用Class空间最大的数据项之一，且是第一个出现的表类型数据项目。</p>
<p>常量池主要存储两大类常量：字面量（Literal）和符号引用（Symbolic References）</p>
<p>字面量相当于Java语言中的常量概念，比如字符串，声明为final的常量值。<br>符号引用则属于编译原理方面的概念包括三类常量：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>Class文件不会保存各个方法字段的最终内存布局信息，因为这些字段、方法和符号引用不经过运行期转换（动态连接）的话无法得到真正内存入口地址，也就无法被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析翻译到具体的内存地址之中。</p>
<p>常量池中的每一项常量都是一个表（JDK1.7中有14种）。包括UTF-8编码的字符串表，整型字面量表，浮点型字面量表，长整型字面常量表，类和接口的符号引用表，字段符号引用表，类中的方法符号引用表，接口中方法符号引用表等等。这些表都会有各自不同的结构。</p>
<p><strong>2.4 访问标志</strong></p>
<p>常量池之后就是由两个字节代表的访问标识（access flags）这些标识用于识别一些类或者接口层次的访问信息，包括这个Class是类还是接口；是否定义为public；是否定义为abstract类型；是否被final修饰。</p>
<p><strong>2.5 类索引、父类索引、接口索引</strong></p>
<p>访问标志位之后就是u2类型的类索引，父类索引和接口索引集合。Class文件由这三项数据确定这个类的继承关系。这三项数据（u2类型的索引值）各指向类型为CONSTANT_Class_info的类描述符常量。</p>
<p><strong>2.6 字段表集合</strong></p>
<p>字段表用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段表中字段的各种描述信息（作用域比如public，private，是否被final，static修饰，是否可序列化等）均使用标志位表示，名称则引用常量池中的常量来描述。</p>
<p><strong>2.7 方法表集合</strong></p>
<p>在方法表中，方法的描述和字段的描述基本一致，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p>
<p>方法中的代码经过编译器编译成字节码指令后存放在方法属性表集合中一个名为“Code”的属性里面。</p>
<p>如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。</p>
<p><strong>2.8 属性表集合</strong></p>
<p>Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<p>为了能正确解析Class文件，在Java SE 7中预定义了21项属性，虚拟机在运行时会忽略他不认识的属性。</p>
<h2 id="3_u3001_u5B57_u8282_u7801_u6307_u4EE4"><a href="#3_u3001_u5B57_u8282_u7801_u6307_u4EE4" class="headerlink" title="3、字节码指令"></a>3、字节码指令</h2><p>Java虚拟机的指令是由一个字节长度的、代表着某种特定操作含义的数字（操作码，Opcode）以及跟随其后的零个至多个代表此操作所需要的参数（操作数，Operands）构成。</p>
<p>常用指令：</p>
<ul>
<li>加载存储指令，将数据在栈帧中的局部变量表和操作数栈之间来回传输</li>
<li>运算指令，对两个操作数栈上的值进行某种特定运算，并把结果重新写入操作栈，包括加减乘除逻辑与或非</li>
<li>类型转换指令，将两种不同的数值类型进行相互转换，这些转换一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令代码无法与数据类型一一对应的问题。另，类型转换指令永远不可能导致虚拟机运行异常。</li>
<li>对象创建与访问指令，创建对象数组访问对象等</li>
<li>操作数栈管理指令，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括入栈，出栈，栈顶端两个数据交换</li>
<li>控制转移指令，可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，包括条件分支ifxxx，复合条件分支，无条件分支goto等。</li>
<li>方法调用和返回指令，调用对象实例方法，调用接口方法，调用类方法，运行时动态解析出调用点限定符所引用的方法，返回指令根据返回值类型区分</li>
<li>异常处理指令，Java程序中显式抛出异常的操作（throw）都是由athrow指令实现，异常处理不是字节码指令实现，而是采用异常表实现</li>
<li>同步指令，方法级同步和方法内部一段指令序列的同步（通过管程Monitor支持），执行线程要求先持有管程，然后才能执行方法，当方法执行完成后释放管程；方法执行期间，执行线程持有管程，任何一个线程都无法再获取同一个管程</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Class/">Class</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟机/">虚拟机</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java虚拟机/">Java虚拟机</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-GC算法与内存回收" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/17/GC算法与内存回收/" class="article-date">
  	<time datetime="2016-07-17T06:13:03.000Z" itemprop="datePublished">2016-07-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/17/GC算法与内存回收/">GC算法与内存回收</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java内存回收虽说是自动完成，但当需要排查各种内存溢出问题以及提高系统并发量时，仍然需要对Java的垃圾回收技术进行必要调节与监控。本文主要介绍垃圾收集器的GC算法与内存回收策略。</p>
<h2 id="u5BF9_u8C61_u5F15_u7528_u7B97_u6CD5"><a href="#u5BF9_u8C61_u5F15_u7528_u7B97_u6CD5" class="headerlink" title="对象引用算法"></a>对象引用算法</h2><p>GC在回收内存之前首先需要知道对象是否存活，只有那些不需要存活的对象才需要回收。常见判断对象是否存活的方法有两种，一种是引用计数器算法，一种是可达性分析算法，这两种算法在行业内都被广泛使用。</p>
<p><strong>引用计数器算法</strong><br>给对象添加一个引用计数器，每当有一个地方引用它时就+1；当引用失效时就-1；任何时刻计数器为0则表示对象不再被使用。</p>
<p>引用计数器算法实现简单，判定效率较高，在一些其他语言与游戏脚本中广泛使用。不过它很难解决对象之间相互循环引用的问题。</p>
<p><strong>可达性分析算法</strong><br>该算法基本思想是：基本通过一系列被称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论说就是从GCRoots到这个对象不可达），则证明此对象不可用。</p>
<p>可达性分析算法在Java，C#等语言的主流实现中用来判定对象是否可用。在Java语言中可作为GC Roots的对象包括：虚拟机栈中引用的对象，方法区中静态属性引用的对象，方法区中常量引用的对象。本地方法栈中JNI引用的对象。</p>
<h2 id="Java_u4E2D_u7684_u56DB_u79CD_u5F15_u7528"><a href="#Java_u4E2D_u7684_u56DB_u79CD_u5F15_u7528" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h2><p>为了描述：一些对象在内存空间足够时则能保存在内存中，当内存空间紧张时则释放掉这些对象。Java将引用的概念扩充为4中，分别为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），这四种引用强度依次减弱。</p>
<p><strong>强引用</strong><br>强引用指在代码中普遍存在的类似<code>Object obj = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器就永远不会回收掉改引用的对象。</p>
<p><strong>软引用</strong><br>软引用用来描述一些还有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p><strong>弱引用</strong><br>弱引用用来描述非必须的对象，但它的强度比软引用要更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集工作时，无论当前内存是否够用，都会回收掉只被弱引用关联的对象。</p>
<p><strong>虚引用</strong><br>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收之前收到一个系统通知。</p>
<h2 id="u5BF9_u8C61_u5185_u5B58_u56DE_u6536"><a href="#u5BF9_u8C61_u5185_u5B58_u56DE_u6536" class="headerlink" title="对象内存回收"></a>对象内存回收</h2><p>一个对象即使被可达性分析算法标记为不可达也并非立即被回收，至少要标记两次才有可能被回收：</p>
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它就会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行。</p>
<p>如果这个对象有必要执行finalize()方法，那么这个对象会被放置到一个F-Queue的队列中，并在稍后由一个虚拟机自动创建的低优先级的Finalizer线程去执行它。不过这里的执行仅仅是虚拟机插法此方法，但并不承诺会等待它运行完成。因为如果finalize执行时间较长或发生死循环会导致F-Queue中的其他对象用于处于等待状态进而导致内存回收系统的崩溃。</p>
<p>稍后GC将对F-Queue中的对象进行第二次小范围的标记，如果对象在finilize中重新建立起引用链连接，那么在第二次标记中就会被移除即将回收的集合；如果对象这时候仍然没有引用链，那么基本上它就要被回收了。</p>
<p>注意：任何一个对象的finalize方法都只会被系统调用一次，如果下一次GC回收，它的finalize方法将不会被执行。</p>
<h2 id="u65B9_u6CD5_u533A_u5185_u5B58_u56DE_u6536"><a href="#u65B9_u6CD5_u533A_u5185_u5B58_u56DE_u6536" class="headerlink" title="方法区内存回收"></a>方法区内存回收</h2><p>像程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而亡，不需要进行内存回收。方法区术语HotSpot虚拟机的永久带，Java虚拟机规范规定可以不对方法区进行回收。而且对于永久带回收内存的效率比较低。</p>
<p>永久带垃圾收集主要包括两部分：废弃的常量、无用的类。常量池中的字符串，类、方法，字段的符号引用如果不在被使用则需要清理出常量池。</p>
<p>判定一个常量是否需要回收比较简单，判断一个类是否需要回收则条件比较苛刻，需要同时满足三个条件：</p>
<ul>
<li>该类所有实例都被回收</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过访问该类的方法</li>
</ul>
<h2 id="u5783_u573E_u6536_u96C6_u7B97_u6CD5"><a href="#u5783_u573E_u6536_u96C6_u7B97_u6CD5" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><strong>标记-清除算法</strong><br>首先标记出所需要回收的对象，在标记完成后统一回收所有被标记（前面介绍过）的对象。</p>
<p>该算法有两个不足，一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收。</p>
<p><strong>复制算法</strong><br>该算法将可用内存按容量大小分为大小相等的两块，每次只使用其中一块。当这一块内存用完了就将还存活的对象复制到另一块上面，这样内存分配时就不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可。</p>
<p>复制算法解决了标记-清除算法的效率问题，实现简单，运行效率高，但将内存缩小为一半代价过高。复制算法在对象存活率较高时会进行过多复制，效率会降低，而且如果不想浪费50%的内存空间就需要额外的空间进行分配担保，以应对被使用内存对象100%存活的极端情况。</p>
<p>新生代在每次垃圾回收时都有大量对象死亡所以特别适用复制算法，而且该算法的改进版不需要按照1:1的比例划分内存空间，只需要按经验值划分即可。</p>
<p><strong>标记-整理算法</strong><br>该算法首先标记出所需要回收的对象，在标记完成后统一后将所有存活的对象统一移动到一端，然后直接清理掉边界以外的内存。</p>
<p>老年代中的对象存活时间都比较久，适用于标记整理算法。</p>
<p><strong>分代收集算法</strong><br>该算法根据对象存活周期将内存划分为不同的几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点分别采用最合适的收集算法。当前商业虚拟机普遍采用分代收集算法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC算法/">GC算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存回收/">内存回收</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟机/">虚拟机</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java虚拟机/">Java虚拟机</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java对象创建与内存分布" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/10/Java对象创建与内存分布/" class="article-date">
  	<time datetime="2016-07-10T06:04:25.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/Java对象创建与内存分布/">Java对象创建与内存分布</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要讲述Java对象在虚拟机中创建，分配内存，初始化的过程，以及分配内存，引用对象的几种常见方式。</p>
<h2 id="u5BF9_u8C61_u521B_u5EFA"><a href="#u5BF9_u8C61_u521B_u5EFA" class="headerlink" title="对象创建"></a>对象创建</h2><p>对象创建分为三部分，首先是类加载，接着是为对象分配内存，最后是初始化。</p>
<p><strong>创建</strong><br>虚拟机遇到new指令时会去检查这个指令参数是否能在常量池中定位到一个符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有则先进性类加载过程。</p>
<p><strong>分配内存</strong><br>对象所需内存大小在类加载完成后即可确定，所以虚拟机只要从堆中划分出相应大小内存分配给新创建的对象即可。</p>
<p>常见的内存分配方式有两种，一种是“指针碰撞”，一种是“空闲列表”。不同的Java虚拟机实现会分别采用这两种内存分配方式。</p>
<p>“指针碰撞”假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放一个指针作为分界点指示器。当需要分配内存时只需要把指针向空闲内存方向移动对象大小相等的距离即可。</p>
<p>如果Java堆中的内存并不规整，那么虚拟机需要维护一个列表用来记录那些内存块可用。当需要分配内存时从列表中找出一个足够大的空间划分给对象实例，这就是“空闲列表”。</p>
<p><strong>初始化</strong><br>虚拟机在对象内存分配完成后首先会将不包括对象头的内存空间初始化为零值，即为对象的字段分配其数据类型所对应的初始值。这一步保证对象的实例字段在Java代码中可以不赋初始值就可使用。</p>
<p>接下来虚拟机向对象头空间写入实例所属类，类的元数据信息获取方式，对象的哈希码，对象GC分代年龄等信息。</p>
<p>然后执行<init>方法按照程序员编写的程序代码将对象进行初始化。（这里就是所谓的对象初始化”两次”的问题）</init></p>
<p><strong>分配内存的线程安全问题</strong><br>对象创建在虚拟机中是非常频繁的过程，并发的情况下并不是线程安全的。解决问题有两种方案，一种是在分配内存时进行同步处理；另一种是为每一个线程在Java堆中预先分配一块内存（即本地线程分配缓冲TLAB），这样线程内存分配的动作分别在不同的内存空间中进行，只有缓冲区内存不足时才会为缓冲区同步分配内存。虚拟机分配内存时还会加上失败重试的方式。</p>
<h2 id="u5BF9_u8C61_u5185_u5B58_u5206_u5E03"><a href="#u5BF9_u8C61_u5185_u5B58_u5206_u5E03" class="headerlink" title="对象内存分布"></a>对象内存分布</h2><p>对象在内存中的分配包括三部分：对象头，实例数据和对齐填充。</p>
<p><strong>对象头</strong><br>对象头包括两部分信息，第一部分是用于存储对象自身的运行时数据，如哈希码，GC分代年龄、锁状态标识、线程持有的锁，偏向线程ID、偏向时间戳等，这部分数据的长度在32为虚拟机中为32bit在64为虚拟机中为64bit，所有数据均以标志位的形式存储。</p>
<p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。但这并不是必须有的，也就是查找对象元数据并不一定需要对象本身。如果对象是数组，那么对象头中还必须记录对象数组长度。</p>
<p><strong>实例数据</strong><br>示例数据部分存储着对象程序代码中定义的各种类型字段内容，包括从父类继承的和子类总定义的。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源代码中定义顺序的影响。虚拟机默认将相同长度的字段分配到一起，且父类定义的变量会出现在子类之前。通过配置虚拟机参数也可以使子类较窄的变量插到父类变量空隙中。</p>
<p><strong>对象填充</strong><br>对象填充仅仅是占位符，并不是必然存在。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍，所以如果对象实例数据部分没有对齐需要对齐填充来补齐（对象头已经对齐）。</p>
<h2 id="u5BF9_u8C61_u8BBF_u95EE"><a href="#u5BF9_u8C61_u8BBF_u95EE" class="headerlink" title="对象访问"></a>对象访问</h2><p>当创建好对象后，我们需要通过引用reference来访问使用对象，常见的有两种方式，第一种是句柄，第二种是直接指针。</p>
<p><strong>句柄</strong><br>Java堆中需要专门划分一部分内存作为句柄池，Java栈中的引用存储的是对象的句柄地址，而句柄地址存储了对象实例数据与数据类型各自的具体地址信息。</p>
<p>使用句柄的好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是普遍的行为）时只会改变句柄中实例数据指针，而reference不需要更改。</p>
<p><strong>直接指针</strong><br>直接指针就是Java栈中的引用直接存储对象的内存地址。使用直接指针最大的好处就是访问速度快，它节省了一次指针定位的时间开销。Sun的Hot Spot虚拟机使用的直接指针访问对象。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存/">内存</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/对象/">对象</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟机/">虚拟机</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java虚拟机/">Java虚拟机</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Git版本管理策略" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/Git版本管理策略/" class="article-date">
  	<time datetime="2016-07-03T06:23:10.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/Git版本管理策略/">Git版本管理策略</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要介绍使用Git这种有主干分支概念的工具开发项目时，进行版本管理的方法。每种方法都对应一些特定情况，使用时可以按需选取。</p>
<h3 id="u4E3B_u5E72_u5F00_u53D1_u4E3B_u5E72_u53D1_u5E03"><a href="#u4E3B_u5E72_u5F00_u53D1_u4E3B_u5E72_u53D1_u5E03" class="headerlink" title="主干开发主干发布"></a>主干开发主干发布</h3><p>在一个开发周期迭代时所有开发测试都在主干分支上进行，待开发完成在主干上打tag发布。</p>
<h3 id="u4E3B_u5E72_u5F00_u53D1_u5206_u652F_u53D1_u5E03"><a href="#u4E3B_u5E72_u5F00_u53D1_u5206_u652F_u53D1_u5E03" class="headerlink" title="主干开发分支发布"></a>主干开发分支发布</h3><p>在主干上进行开发任务，发布时从主干上拉一个分支并进行测试与bug修复工作，待测试修复完成后在分支上发布，并将发布代码合并到主干上。</p>
<h3 id="u5206_u652F_u5F00_u53D1_u5206_u652F_u53D1_u5E03"><a href="#u5206_u652F_u5F00_u53D1_u5206_u652F_u53D1_u5E03" class="headerlink" title="分支开发分支发布"></a>分支开发分支发布</h3><p>每次开发周期迭代时都重新拉一个开发分支，在这个周期内所有开发任务都在这个分支上进行。待开发测试完成再将这个分支合并到主干分支上。</p>
<h3 id="u9879_u76EE_u5EF6_u671F"><a href="#u9879_u76EE_u5EF6_u671F" class="headerlink" title="项目延期"></a>项目延期</h3><p>由于种种原因没能完成开发任务，这时候需要在主干上单独拉一个分支进行延期项目开发，已完成的任务按原计划发布。在新分支上完成开发测试后再合并到主干分支上。</p>
<h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>发现重大Bug需要专门拉取一个分支进行修复，并在修复完成后合并到主干分支上。</p>
<p>对于客户端，可能需要修复某一个版本的bug，在此版本tag上拉取分支，修复完成后在此分支上发布。</p>
<h3 id="u5B9A_u5236_u4EFB_u52A1"><a href="#u5B9A_u5236_u4EFB_u52A1" class="headerlink" title="定制任务"></a>定制任务</h3><p>对于客户端，可能需要为一些渠道定制开发，所以在主干分支上专门拉取一个分支进行开发，并在开发完成后发布。此次定制功能并不是主干代码需要的功能，不必合到主干分支上。</p>
<h3 id="u4E3E_u4F8B"><a href="#u4E3E_u4F8B" class="headerlink" title="举例"></a>举例</h3><p>在实际开发工作中，项目发布可能会在master分支上进行，而开发则会在develop分支上进行。</p>
<p>大家都在develop分支上开发，但总有一些情况导致某一两个项目无法在发布之前完成，然而所有代码无论开发完成的还是未开发完成的都在develop分支上。</p>
<p>这时候可以在develop分支上再开一个分支，develop上进行一些处理并进行一系列测试与bug修复工作，待测试完成将develop合并到master上发布。而新分支则继续进行延期项目开发，待开发完成合并到develop上，在下一个版本时发布。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/版本管理/">版本管理</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Git/">Git</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-React-Native语法指南" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/12/React-Native语法指南/" class="article-date">
  	<time datetime="2016-06-12T06:25:06.000Z" itemprop="datePublished">2016-06-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/12/React-Native语法指南/">React Native语法指南</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React Native真的是越来越流行，没使用React Native开发项目都不好意思说自己是搞客户端开发的。对于纯Native开发者来说，刚上手React Native有一定的适应期，如果JavaScript也不熟练的话那就更悲催了。React Native涉及ES6，React语法，JSX，前端调试，Native客户端等知识，本文简单总结了React Native开发中一些知识点。算是在学习中的积累。</p>
<h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>Component：组件，使用<code>React.createClass</code>或者<code>extends React.Component</code>创建的类为组件。<br>Element：元素或者可以说是组件的实例，使用<code>&lt;Label /&gt;</code>或者<code>let label = new Label()</code>创建的为实例。</p>
<p>对于定义组件，React以前版本的写法(ES5):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Lable  = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>React最新的写法(ES6):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="props_u4E0Estate"><a href="#props_u4E0Estate" class="headerlink" title="props与state"></a>props与state</h2><p>props属性：组件可以定义初始值，自己不可更改props属性值，只允许从父组件中传递过来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="title">Label</span> <span class="attribute">name</span>=<span class="value">"标题栏"</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="title">Text</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="title">Text</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>父组件向Label传递name=”标题栏”的props属性，在Label中使用this.props.name引用此属性。</p>
<p>state属性：组件用来改变自己状态的属性，通常使用<code>setState({key:value})</code>来改变属性值，不能使用<code>this.state.xxx</code>来直接改变，<code>setState({key:value})</code>方法会触发界面刷新。</p>
<p>对于经常改变的数据且需要刷新界面显示，可以使用state。对于不需要改变的属性值可以使用props。React Native建议由顶层的父组件定义state值，并将state值作为子组件的props属性值传递给子组件，这样可以保持单一的数据传递。</p>
<p>在以前版本的React中定义state，props可以使用生命周期方法 <code>getInitialState()</code>和<code>getInitialState()</code>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Label = React.createClass(&#123;</span><br><span class="line">    getInitialState()&#123;</span><br><span class="line">        key:value,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    getInitialProps()&#123;</span><br><span class="line">        key:value,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,<span class="comment">// 这种写法需要有，不要使用；</span></span><br><span class="line">    render:funation()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在最新版本的React可以使用构造函数替代getInitialState()，getInitialState()方法定义初始值：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            time: <span class="string">'2016'</span>,</span><br><span class="line">            city: <span class="string">'上海'</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.props = &#123;</span><br><span class="line">            name:<span class="string">'标题'</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u9ED8_u8BA4props_u4E0Eprops_u6821_u9A8C"><a href="#u9ED8_u8BA4props_u4E0Eprops_u6821_u9A8C" class="headerlink" title="默认props与props校验"></a>默认props与props校验</h2> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 默认props</span></span><br><span class="line">   static defaultProps = &#123;</span><br><span class="line">      city: <span class="string">'南京'</span>,</span><br><span class="line">      index: <span class="number">12</span>,</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// propTypes用于验证转入的props，当向 props 传入无效数据时，JavaScript 控制台会抛出警告</span></span><br><span class="line">   static propTypes = &#123;</span><br><span class="line">      city: React.PropTypes.string.isRequired,</span><br><span class="line">      index: React.PropTypes.number.isRequired,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   state = &#123;</span><br><span class="line">      city: <span class="keyword">this</span>.props.city,</span><br><span class="line">      index：<span class="keyword">this</span>.props.index,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认props</span></span><br><span class="line">Label.defaultProps = &#123;</span><br><span class="line">    city: <span class="string">'南京'</span>,</span><br><span class="line">    index: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// propTypes用于验证转入的props，当向 props 传入无效数据时，JavaScript 控制台会抛出警告</span></span><br><span class="line">Label.propTypes = &#123;</span><br><span class="line">    city: React.PropTypes.string.isRequired,</span><br><span class="line">    index: React.PropTypes.number.isRequired,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><p>我们把组件从<code>装载</code>,到<code>渲染</code>，再到<code>卸载</code>当做一次生命周期，也就是组件的生存状态从<code>装载</code>开始到<code>卸载</code>为止，期间可以根据属性的变化进行多次渲染。</p>
<p>生命周期的三种状态：</p>
<ul>
<li>Mounting：装载，</li>
<li>Updating：渲染</li>
<li>Unmounting：卸载</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillMount</span><span class="params">()</span></span>，组件开始装载之前调用，在一次生命周期中只会执行一次。</span><br><span class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span>，组件完成装载之后调用，在一次生命周期中只会执行一次，从这里开始就可以对组件进行各种操作了，比如在组件装载完成后要显示的时候执行动画。</span><br><span class="line"><span class="function"><span class="title">componentWillUpdate</span><span class="params">(object nextProps, object nextState)</span></span>，组件属性更新之前调用，每一次属性更新都会调用</span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span><span class="params">(object prevProps, object prevState)</span></span>，组件属性更新之后调用，每次属性更新都会调用</span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span>，组件卸载之前调用</span><br></pre></td></tr></table></figure>
<p>组件属性更改时会调用以下方法，在一次生命周期中可以执行多次：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillReceiveProps</span><span class="params">(object nextProps)</span></span>，已加载组件收到新的参数时调用</span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span><span class="params">(object nextProps, object nextState)</span></span>，组件判断是否重新渲染时调用</span><br></pre></td></tr></table></figure></p>
<h2 id="u9875_u9762_u8DF3_u8F6C"><a href="#u9875_u9762_u8DF3_u8F6C" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>初始化第一个页面：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">SeatPageComponent</span> from './<span class="type">SeatPageComponent</span>';</span><br><span class="line"><span class="keyword">import</span> <span class="type">MainPageComponent</span> from './<span class="type">MainPageComponent</span>';</span><br><span class="line"><span class="keyword">import</span> <span class="type">TrainListComponent</span> from './<span class="type">TrainListComponent</span>';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainPage</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        let defaultName = <span class="symbol">'MainPageComponen</span>t';</span><br><span class="line">        let defaultComponent = <span class="type">MainPageComponent</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">Navigator</span></span><br><span class="line">                <span class="comment">// 指定默认页面</span></span><br><span class="line">                initialRoute=&#123;&#123; name: defaultName, component: defaultComponent &#125;&#125;</span><br><span class="line">                <span class="comment">// 配置页面间跳转动画</span></span><br><span class="line">                configureScene=&#123;(route) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="type">Navigator</span>.<span class="type">SceneConfigs</span>.<span class="type">VerticalDownSwipeJump</span>;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">                <span class="comment">// 初始化默认页面</span></span><br><span class="line">                renderScene=&#123;(route, navigator) =&gt; &#123;</span><br><span class="line">                    let <span class="type">Component</span> = route.component;</span><br><span class="line">                    <span class="comment">// 将navigator作为props传递到下一个页面</span></span><br><span class="line">                    <span class="keyword">return</span> &lt;<span class="type">Component</span> &#123;...route.params&#125; navigator=&#123;navigator&#125; /&gt;</span><br><span class="line">                &#125;&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跳转到下一页面：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jumpToNext()&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; navigator &#125; = <span class="keyword">this</span>.props;<span class="comment">// 由上一个页面传递过来</span></span><br><span class="line">      <span class="keyword">if</span>(navigator) &#123;</span><br><span class="line">          navigator.push(&#123;</span><br><span class="line">              name: <span class="string">'SeatPageComponent'</span>,</span><br><span class="line">              component: SeatPageComponent,<span class="comment">// 下一个页面</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回上一个页面：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_back()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; navigator &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span>(navigator) &#123;</span><br><span class="line">        navigator.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u9875_u9762_u95F4_u901A_u4FE1"><a href="#u9875_u9762_u95F4_u901A_u4FE1" class="headerlink" title="页面间通信"></a>页面间通信</h2><p>例如：从A页面打开B页面<br>A通过route.params将参数传递给B：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jumpToNext()&#123; </span><br><span class="line">    <span class="keyword">const</span> &#123; navigator &#125; = <span class="keyword">this</span>.props;<span class="comment">// 由上一个页面传递过来</span></span><br><span class="line">    <span class="keyword">if</span>(navigator) &#123; </span><br><span class="line">        navigator.push(&#123; </span><br><span class="line">            name: <span class="string">'SeatPageComponent'</span>, </span><br><span class="line">            component: SeatPageComponent,<span class="comment">// 下一个页面 </span></span><br><span class="line">            <span class="keyword">params</span>: &#123; <span class="comment">// 需要传递个下一个页面的参数,第二个页面使用this.props.<span class="label">xxx获取参数</span></span></span><br><span class="line">                id: <span class="number">123</span>,</span><br><span class="line">                title: <span class="keyword">this</span>.state.title, </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A通过route.params传递回调方法或者A的引用来让B将数据传回给A：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A页面</span></span><br><span class="line">jumpToNext()&#123; </span><br><span class="line">    <span class="keyword">const</span> &#123; navigator &#125; = <span class="keyword">this</span>.props;<span class="comment">// 由上一个页面传递过来</span></span><br><span class="line">    <span class="keyword">if</span>(navigator) &#123; </span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;<span class="comment">// this作用域，参见下文函数绑定</span></span><br><span class="line">        navigator.push(&#123; </span><br><span class="line">            name: <span class="string">'SeatPageComponent'</span>, </span><br><span class="line">            component: SeatPageComponent,<span class="comment">// 下一个页面 </span></span><br><span class="line">            params: &#123; <span class="comment">// 需要传递个下一个页面的参数,第二个页面使用this.props.<span class="label">xxx获取参数</span></span></span><br><span class="line">                title: <span class="string">'测试'</span>,</span><br><span class="line">                getName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;that.setState(&#123; name: name &#125;)&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B页面</span></span><br><span class="line"> _back()&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; navigator &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.props.getName)&#123;</span><br><span class="line">         <span class="keyword">this</span>.props.getName(<span class="string">'测试'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(navigator) &#123;</span><br><span class="line">         navigator.pop();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u7EC4_u4EF6_u95F4_u901A_u4FE1"><a href="#u7EC4_u4EF6_u95F4_u901A_u4FE1" class="headerlink" title="组件间通信"></a>组件间通信</h2><p>父组件–&gt;子组件， 使用props，父组件向子组件传递props</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="title">Label</span> <span class="attribute">name</span>=<span class="value">"标题栏"</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="title">Text</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="title">Text</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子组件–&gt;父组件， 父组件在创建子组件时传递回调方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'测试'</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 回调方法</span></span><br><span class="line">    getName(str)&#123;</span><br><span class="line">         <span class="keyword">this</span>.setState(&#123;name:str&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="title">Label</span> <span class="attribute">name</span>=<span class="value">"标题栏"</span> <span class="attribute">getName</span>=<span class="value">&#123;getName&#125;</span>/&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="title">View</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">TouchableOpacity</span> <span class="attribute">onPress</span>=<span class="value">&#123;()=</span>&gt;</span>this._onPress()&#125;&gt;</span><br><span class="line">                          <span class="tag">&lt;<span class="title">Text</span>&gt;</span>点我，&#123;this.props.name&#125;<span class="tag">&lt;/<span class="title">Text</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="title">TouchableOpacity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">View</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _onPress()&#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>.props.getName)&#123;</span><br><span class="line">              <span class="keyword">this</span>.props.getName(<span class="string">'测试'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非父子关系的组件，即没有任何嵌套关系的组件， 可以引入订阅源(<a href="http://millermedeiros.github.io/js-signals/" target="_blank" rel="external">js-signals</a>, <a href="https://github.com/mroderick/PubSubJS" target="_blank" rel="external">PubSubJS</a>)，监听订阅事件。例如，在生命周期方法中addEventListener()，removeEventListener()，在合适时机setState()。</p>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>ES6中函数的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    doSomething()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="comment">// 不要使用逗号或者分号作为结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>key:value形式定义函数的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Label = React.createClass(&#123;</span><br><span class="line">    doSomething:funation()&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,<span class="comment">// 需要使用逗号作为结尾，不能使用分号</span></span><br><span class="line">    doSomething2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>函数绑定<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有函数</span></span><br><span class="line">    sayHello(str)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在onPress中使用箭头函数调用</span></span><br><span class="line">    <span class="comment">// onPress=&#123;() =&gt; this.sayHello('Hello')&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">//onPress=&#123;sayHello('hello').bind(this)&#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// onPress=&#123;print('hello',this)&#125;</span></span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">              <span class="xml"><span class="tag">&lt;<span class="title">View</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="title">TouchableOpacity</span> <span class="attribute">onPress</span>=<span class="value">&#123;()</span> =&gt;</span> this.sayHello('Hello')&#125;&gt;</span><br><span class="line">                          <span class="tag">&lt;<span class="title">Text</span>&gt;</span>点我<span class="tag">&lt;/<span class="title">Text</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="title">TouchableOpacity</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">View</span>&gt;</span></span><br><span class="line">        )</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">str,this</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;<span class="comment">// 注意这里this的生命周期</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">            that.sayHello(str)<span class="comment">// 此处不能再使用this</span></span><br><span class="line">        &#125;</span><br><span class="line">        say(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>require，import：javascript的模块管理工具，管理各个模块之间的引用，解决javascript异步加载的问题，解决js写成多个文件后浏览器加载缓慢的问题。</p>
<p>JavaScript中没有private，public的概念<br>使用_开头的方法代表private方法，不适用则表示public方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span>&#123;</span></span><br><span class="line">    <span class="comment">// private 函数</span></span><br><span class="line">    _doSomething()&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// public 函数</span></span><br><span class="line">    doSomething()&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考资料<br><a href="http://reactjs.cn/react/docs/reusable-components.html" target="_blank" rel="external">Reactjs中文教程</a><br><a href="http://wiki.jikexueyuan.com/project/react/communicate.html" target="_blank" rel="external">极客学院React教程</a><br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript语法</a><br><a href="http://my.oschina.net/eonezhang/blog/522750" target="_blank" rel="external">JavaScript模块系统</a><br><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">require.js</a><br><a href="http://bbs.reactnative.cn/topic/20/%E6%96%B0%E6%89%8B%E7%90%86%E8%A7%A3navigator%E7%9A%84%E6%95%99%E7%A8%8B" target="_blank" rel="external">Navigator</a><br><a href="https://segmentfault.com/a/1190000003742747" target="_blank" rel="external">结合ES6+开发React</a><br><a href="http://www.tuicool.com/articles/AzQzEbq" target="_blank" rel="external">React组件通信</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/教程/">教程</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/React-Native/">React Native</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android进程通信原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/11/Android进程通信原理/" class="article-date">
  	<time datetime="2016-06-11T06:51:56.000Z" itemprop="datePublished">2016-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/11/Android进程通信原理/">Android进程通信原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android系统提供了一些通用服务，比如音乐打电话发短信，WIFI，定位，输入法，传感器等。应用程序与这些通用服务运行在不同的进程中，如果应用程序想要与这些通用服务交互就要涉及到进程间通信，Binder就是为了Android进程间通信而设计的。</p>
<h2 id="Binder_u6846_u67B6"><a href="#Binder_u6846_u67B6" class="headerlink" title="Binder框架"></a>Binder框架</h2><p>Binder是一种架构，这种架构提供了服务端接口、Binder驱动、客户端接口三个模块。</p>
<p><strong>服务端</strong><br>Binder服务端相当于一个Binder类对象。当创建该对象时，其内部会启动一个线程不断接收Binder驱动发送的消息。收到消息后会执行Binder.onTransact()方法。所以要实现一个Binder服务就必须重载onTransact()方法。</p>
<p>onTransact()方法通常用来做数据格式转换，按约定的顺序取出Binder客户端发送来的数据并转换成服务端识别的数据格式。</p>
<p><strong>Binder驱动</strong><br>Binder驱动运行在内核态，其所有操作都是基于内存而非硬件，客户端与服务端通信时需要Binder驱动进行中转。</p>
<p>当一个服务端Binder被创建时其在Binder驱动中同时会创建一个mRemote引用指向服务端。客户端要访问服务端时首先要获取服务端在Binder中的引用mRemote，获取引用后就可以通过mRemote.transact()方法向服务端发送消息。</p>
<p>transact()方法实现了以下几个功能：</p>
<ul>
<li>以线程间消息通信的模式向服务端发送客户端传递过来的参数。</li>
<li>挂起当前客户端线程，等待服务端线程执行完毕后的通知(notify)</li>
<li>接收服务端线程通知，继续执行客户端线程，并返回执行结果</li>
</ul>
<p><strong>客户端</strong><br>这里就是指我们需要和系统服务交互的应用程序。应用程序使用startService()与应用程序Service建立连接，使用getSystemService()与系统Service建立连接，从而进行通信。</p>
<p><strong>数据格式</strong><br>在进行IPC通信时需要约定客户端与服务端通信的数据格式。Android使用AIDL（Android Interface Definition Language）约定数据格式。</p>
<p>Android提供了一个AIDL工具，可以把AIDL文件转换成一个Java类，在该Java类中同时重载了onTransact()方法和transact()方法，统一了存入和读取参数。</p>
<h2 id="u5B9E_u73B0Binder_u670D_u52A1_u7AEF"><a href="#u5B9E_u73B0Binder_u670D_u52A1_u7AEF" class="headerlink" title="实现Binder服务端"></a>实现Binder服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicService</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code,data,reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码基于Binder创建了一个Service，使用startService()方法启动后就可以看到DDMS中多了一个线程。</p>
<p>重载onTransact(int code, Parcel data, Parcel reply, int flags)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(code)&#123;</span><br><span class="line">     code <span class="number">1000</span>:</span><br><span class="line">            data.enforceInterface(<span class="string">"MusicService"</span>);<span class="comment">// 数据校验与客户端writeInterfaceToken()对应</span></span><br><span class="line">            String filePath = data.readString();<span class="comment">//读取一个字符串</span></span><br><span class="line">            start(filePath);</span><br><span class="line">            <span class="comment">// reply.write<span class="label">XXX();//如果需要返回结果则写入reply中</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>data中保存着客户端传递过来的参数，onTransact()方法内部需要从data中读取客户端传递的参数。参数的位置格式需要在AIDL文件中约束。<br>reply中保存服务端返回客户端的结果，如果需要返回则调用Parcel提供的相关方法写入结果。参数的位置格式需要在AIDL文件中约束。<br>code变量标识客户端希望服务端执行哪个方法，这里假定1000执行start()方法。<br>flags表示IPC调用模式：0代表”双向模式”，服务端在执行完指定服务后会返回数据；1代表”单向模式”，服务端在执行完指定服务后不反回任何数据。</p>
<h2 id="u5B9E_u73B0Binder_u5BA2_u6237_u7AEF"><a href="#u5B9E_u73B0Binder_u5BA2_u6237_u7AEF" class="headerlink" title="实现Binder客户端"></a>实现Binder客户端</h2><p>首先在startService()，getSystemService()中获取服务端Binder的引用，然后将参数按AIDL定义的格式写入data中并调用mRemote.transact()方法传入参数，服务端会在onTransact()方法中取出这里出入的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IBinder mRemote = <span class="keyword">null</span>;</span><br><span class="line">String filePath = <span class="string">"/sdcard/music/xxx.mp3"</span>;</span><br><span class="line"><span class="keyword">int</span> code = <span class="number">1000</span>;</span><br><span class="line">Parcel data = Parcel.obtain();</span><br><span class="line">Parcel reply = Parcel.obtain();</span><br><span class="line">data.writeInterfaceToken(<span class="string">"MusicService"</span>);</span><br><span class="line">data.writeString(filePath);</span><br><span class="line">mRemote.transact(code,data,reply,<span class="number">0</span>);</span><br><span class="line">IBinder binder = reply.readStrongBinder();</span><br><span class="line">reply.recycle();</span><br><span class="line">data.recycle();</span><br></pre></td></tr></table></figure></p>
<p>调用mRemote.transact()方法后，Binder驱动会挂起当前客户端线程，并向服务端发送一个消息，这个消息就包括客户端传递的参数。服务端接收到消息，解析数据执行完相关任务后会把执行结果写入reply中，然后向Binder驱动发送一个notify消息，Binder驱动从挂起处唤醒客户端线程继续执行。</p>
<h2 id="u7CFB_u7EDFService_u4E0E_u5E94_u7528_u7A0B_u5E8FService"><a href="#u7CFB_u7EDFService_u4E0E_u5E94_u7528_u7A0B_u5E8FService" class="headerlink" title="系统Service与应用程序Service"></a>系统Service与应用程序Service</h2><p>Service也就是服务分为两种，一种是系统创建的Service，另一种是应用程序自定义的Service。这两种Service都是Binder服务端。</p>
<p><strong>系统Service</strong><br>系统Service在系统系统初始化时从SystemServer进程中启动。常见的有PowerManagerService（电源管理服务），VibratorService（振动传感器服务），WindowManagerService（窗口管理服务）NotificationManagerService等等，每个系统服务都是一个Binder，都运行在一个独立的线程中。</p>
<p>系统提供了一个ServiceManager类来管理系统服务ServiceManager本身也是一个Binder，运行在一个独立的进程中，其提供了一个全局Binder供应用程序使用，应用程序获取其他系统服务都是通过ServiceManager的全局Binder来获取的。</p>
<p>这设计的好处仅仅暴露一个全局Binder引用，其他系统服务则隐藏起来，从而有助于系统扩展，以及调用系统服务的安全检查。</p>
<p>系统Service在启动时首先向ServiceManager注册Service（注册自己），当调用getSystemService(serviceName)获取系统服务时，会间接调用到ServiceManager.getService(String name)方法。getService()实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span>(service != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RemoteException e)&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"error in get Service"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先从缓存中获取，没获取到则从getIServiceManager()中获取，getIServiceManager()返回的是系统唯一ServiceManager的Binder。</p>
<p><strong>应用程序Service</strong><br>系统在ActivityManagerService中提供了startService()方法来启动应用程序自定义Service。客户端使用以下方法和应用程序Service建立连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent intent)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,<span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure></p>
<p>startService用于启动一个服务，bindService用于绑定一个服务，bindService的第二个参数是获取服务端Binder的关键所在：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceConnection</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name,IBinder service)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onServiceConnected()方法的第二个变量就是我们需要的服务端Binder的引用，当客户端请求AmS启动某个Service，如果该Service正常启动，那么AmS就会远程调用ActivityThread类中的ApplicationThread对象，调用的参数包括Service的Binder引用，然后在ApplicationThread中会回调bindService()方法中的conn接口。因此，在客户端中，可以在onServiceConnected()方法中将其参数Service保存为一个全局变量，从而在客户端任何地方都可以随时调用该服务。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IPC/">IPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/进程间通信/">进程间通信</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android内核剖析/">Android内核剖析</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android-内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/02/Android-内存管理/" class="article-date">
  	<time datetime="2016-06-02T06:45:24.000Z" itemprop="datePublished">2016-06-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/02/Android-内存管理/">Android 内存管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android是一个基于Linux实现的操作系统。但对于Linux内核来说，Android也仅仅只是一个运行在内核之上的应用程序，与其他运行在内核之上的应用程序没有任何区别。所以Android需要一套机制管理运行在Linux进程中的APK应用程序。Android内存管理包含两部分，一部分是Framework对内存的管理，一部分是Linux内核对内存管理，这两部分共同决定应用程序的生命周期。本文主要阐述Android内存管理机制的实现原理，以及在应用开发中需要注意的一些事项，最后本文总结了如何实现杀不死进程的一种方法。</p>
<h2 id="Linux__u8FDB_u7A0B_u56DE_u6536"><a href="#Linux__u8FDB_u7A0B_u56DE_u6536" class="headerlink" title="Linux 进程回收"></a>Linux 进程回收</h2><p>在Android中，大部分应用程序都运行在一个独立的Linux进程中，每个进程都有独立的内存空间。随着各种应用程序启动，系统内存不断下降，为了保证新应用能够运行，Android需要一套机制杀死暂时闲置的进程。</p>
<p>Android Framework并不能直接回收内存，其管理进程的服务（ActivityManagerService，以下简称AmS）也同应用程序一样运行在Java虚拟机环境里。Java虚拟机都运行在各自独立的内存空间，所以ActivityManagerService没有办法感知应用程序是否OOM。</p>
<p>Android系统中还运行了一个OOM进程。该进程启动时首先会在Linux内核中把自己注册为一个OOM Killer。AmS需要把每一个应用程序的oom_adj值告知OOM Killer，这个值的范围在-16到15之间，值越低，说明越重要，这个值类似于Linux中的nice值，只在标准的Linux中，有其自己的OOM Killer。Android中的OOM Killer进程仅仅适用于Android应用程序。</p>
<p>当内核的内存管理模块检测到系统内存不足时就会通知OOM Killer，然后OOM Killer根据AmS所告知的优先级强制退出优先级低的应用程序。</p>
<h2 id="u5E94_u7528_u7A0B_u5E8F_u5728_u5185_u5B58_u4E2D_u7684_u72B6_u6001"><a href="#u5E94_u7528_u7A0B_u5E8F_u5728_u5185_u5B58_u4E2D_u7684_u72B6_u6001" class="headerlink" title="应用程序在内存中的状态"></a>应用程序在内存中的状态</h2><p>Android官方声称，Activity退出后，其所在进程并不会被立即杀死，从而在下次启动Activity时，能够提高启动速度。这些Activity只有在内存紧张时才会被系统杀死。所以对于应用程序来说，关闭并不意味着释放内存。</p>
<p><strong>Activity在内存中的状态</strong><br>系统只有一个Activity处于与用户交互的状态，对于非交互状态的Activity，AmS会在内部暂时缓存起来而不是立即杀死，但如果后台Activity数目超过一定阈值，AmS则会强制杀死一些优先级低的Activity。以下是Activity在内存或者说在AmS中的状态：</p>
<ul>
<li>AmS会记录最近启动的20个Activity，如果超过20则舍弃最早记录的Activity。</li>
<li>AmS会将所有正在运行的Activity保存在一个列表中，对于使用back返回的Activity则从列表中清除。</li>
<li>AmS使用Lru算法保存所有最近使用过的Activity。</li>
<li>AmS使用一个列表（mStoppingActivities）保存需要停止的Activity，这种情况<br>发生在启动一个Activity时，AmS遵循先启动后停止的策略，将需要停止的Activity保存在此列表中，等AmS闲置下来后再停止Activity。</li>
<li>AmS使用一个列表保存处于finish状态(onDestory())的Activity，当一个Activity处于finish状态时（onDestory()执行后）不会被立即杀死，而是保存到该列表中直到超过系统设定的警戒线才会回收该列表中的Activity。</li>
</ul>
<p><strong>应用进程在内存中的状态</strong><br>每个应用程序都对应着一个ActivityThread类，该类初始化后就进入Looper.loop()函数中无限循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br><span class="line">...</span><br><span class="line">ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">thread.attach(<span class="keyword">false</span>);</span><br><span class="line">...</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure></p>
<p>以后则依靠消息机制运行，既当有消息时处理消息，没有消息则应用进程进入sleep状态。loop()方法内部代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Looper me = myLooper();</span><br><span class="line">  MessageQueue queue = me.mQueue;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    Message msg = queue.next();<span class="comment">// might block</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Linux内核调度中，如果一个线程的状态为sleep，则除了占用调度本身的时间，不会占用CPU时间片。</p>
<p>有三种情况会唤醒应用线程，一种是定时器中断（比如我们设置的闹钟，在程序中可以设置定时任务），第二种是用户按键消息，第三种是Binder消息（Binder用于进程间通信，其在应用程序中会自动创建一个线程，Binder在接收到消息后会想UI主线程发送一个消息从而使queue.next()继续执行）这就是所谓的消息驱动模式。</p>
<p>所以设计良好的应用程序当处于后台时不会占用任何CPU时间，更不会拖慢系统运行速度。其所占用的仅仅是内存，即使释放所占用的内存也不会提高系统运行速度。当然这里说的是设计良好的应用程序，目前国内很多应用在处于后台状态时依然会偷偷干很多事情，这无疑就拖慢了系统运行速度。</p>
<h2 id="Android__u5185_u5B58_u56DE_u6536"><a href="#Android__u5185_u5B58_u56DE_u6536" class="headerlink" title="Android 内存回收"></a>Android 内存回收</h2><p>Activity所占内存在一般情况下不会被回收，只有在系统内存不够用时才会回收，并且回收会遵循一定规则。大致可以概括为前台Activity最后回收，其次是包含前台的Service或者Provider，再其次是后台Activity，最后是空进程。</p>
<p><strong>内存释放的三个地方</strong></p>
<ul>
<li>第一个是在ActivityManagerService中运行，即Android所声称的当系统内存低时，优先释放没有任何Activity的进程，然后释放非前台Activity对应的进程。</li>
<li>第二个是在OOM Killer中，此时AmS只要告诉OOM各个应用的优先级，然后OOM就会调用Linux内部的进程管理方法杀死优先级较低的进程。</li>
<li>第三个是在应用进程本身之中，当AmS认为目标进程需要被杀死时，首先会通知目标进程进程内存释放。这包括调用目标进程的scheduleLowMemory()方法和processInBackground()方法。</li>
</ul>
<p><strong>关闭Activity的三种情况</strong></p>
<ul>
<li>第一种，从调用startActivity()开始，一般情况下，当前都有正在运行的Activity，所以需要先暂停当前的Activity，而暂停完毕后，AmS会收到一个Binder消息，并开始从completePaused()处执行。在该函数中，由于上一个Activity并没有finishing，仅仅是stop，所以这里会把上一个Activity添加到mStoppingActivity列表中。当目标Activity启动后，会向Ams发送一个请求进行内存回收的消息，这会导致AmS在内部调用activityIdleInternal()方法，该方法中首先会处理mStoppingActivities列表中的Activity，这就会调用stopActivityLocked()方法。这又会通过IPC调用，通知应用进程stop指定的Activity，当stop完毕后，再报告给AmS，于是AmS再从activityStopped()出开始执行，而这会调用trimApplication()方法，该方法会执行内存相关的操作。</li>
<li>第二种，当按Back键后，会调用finishActivityLocked()，然后把该Activity的finishing标识设为true，然后再调用startPausingLocked()，当目标Activity完成暂停后，就会报告AmS，此时AmS又会从completePaused()处开始执行。与第一种情况不同，由于此时暂停的Activity的finishing状态已经设置为true，所以会执行finishingActivityLocked()，而不是像第一种情况中仅仅把该Activity添加到mStoppingActivities列表。</li>
<li>第三种，当Activity启动后，会向AmS发送一个Idle消息，这会导致AmS开始执行activityIdleInternal()方法。该方法会首先处理mStoppingActivities列表中的对象，接着处理mFinishingActivities列表，最后再调用trimApplication()方法。</li>
</ul>
<p>以上就是关闭Activity的三种情况，包括stop和destory，客户进程中与之对应的就是onStop()和onDestory()的调用。</p>
<p>如果使用OOM还有AmS机制杀死后台进程后，此时运行的Activity数量依然超过MAX_ACTIVITIES(20)，则需要继续销毁满足以下三个条件的Activity：</p>
<ol>
<li>Activity必须已经stop，但却没有finishing</li>
<li>必须是不可见的，既该Activity窗口上面有其他全屏的窗口，如果不是全屏，则后面的Activity是可见的。</li>
<li>不能是persistent类型，既常驻进程不能被杀死。</li>
</ol>
<h2 id="u8FDB_u7A0B_u4F18_u5148_u7EA7"><a href="#u8FDB_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>Android系统试图尽可能长时间地保持应用程序进程，但为了新建或者运行更加重要的进程，总是需要清除过时进程来回收内存。为了决定保留或终止哪个进程，根据进程内运行的组件及这些组件的状态，系统把每个进程都划入一个“重要性层次结构”中。重要性最低的进程首先会被清除，然后是下一个最低的，依此类推。</p>
<p>重要性层次结构共有5级，以下列表按照重要程度列出了各类进程（第一类进程是<em>最重要</em>的，将最后一个被终止）：</p>
<p>1）前台进程</p>
<p>用户当前操作所必须的进程。满足以下任一条件时，进程被视作处于前台：<br>其中运行着正与用户交互的Activity（Activity对象的onResume()方法已被调用）。<br>其中运行着与用户交互的activity绑定的Service。<br>其中运行着前台Service，既该Service以startForeground()方式被调用。<br>其中运行着正在执行生命周期回调方法（onCreate()、onStart()或onDestory()）的Service。<br>其中运行着正在执行onReceive()方法的BroadcastReceiver。</p>
<p>一般而言，任何时刻前台进程的数量都为数不多，只有当内存不足以维持它们同时运行时才会被终止。通常，设备这时候已经到了使用虚拟内存的地步，终止一些前台进程是为了保证用户界面的及时响应。</p>
<p>2） 可见进程</p>
<p>没有前台组件、但仍会影响用户在屏幕上所见内容的进程。满足以下任一条件时，进程被认为是可见的：<br>其中运行着非前台Activity，但用户仍然可见到此activity（onPause()方法被调用）。例如，打开了一个对话框，而activity还允许显示在对话框后面，对用户依然可见。<br>其中运行着被可见（或前台）activity绑定的Service。</p>
<p>可见进程被认为是非常重要的进程，除非无法维持所有前台进程同时运行了，否则它们是不会被终止的。</p>
<p>3） 服务进程</p>
<p>此进程运行着由startService()方法启动的服务，它不会升级为前台进程或可见进程。尽管服务进程不直接和用户所见内容关联，但他们通常在执行一些用户关心的操作（比如在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台、可见进程同时运行，系统会保持服务进程的运行。</p>
<p>4） 后台进程</p>
<p>包含用户不可见activity（Activity对象的onStop()方法已被调用）的进程。这些进程对用户体验没有直接的影响，系统可能在任意时间终止它们，以回收内存供前台进程、可见进程及服务进程使用。</p>
<p>通常系统会有很多后台进程在运行，所以它们被保存在一个LRU（最近最少使用）列表中，以确保最近被用户使用的activity最后一个被终止。如果一个activity正确实现了生命周期方法，并保存了当前的状态，则终止此类进程不会对用户体验产生可见的影响。因为在用户返回时，activity会恢复所有可见的状态。关于保存和恢复状态的详细信息，请参阅Activity文档。</p>
<p>5） 空进程</p>
<p>不含任何活动应用程序组件的进程。保留这种进程的唯一目的就是用作缓存，以改善下次在此进程中运行组件的启动时间。为了在进程缓存和内核缓存间平衡系统整体资源，系统经常会终止这种进程。</p>
<p>依据进程中目前活跃组件的重要程度，Android会给进程评估一个尽可能高的级别。例如，如果一个进程中运行着一个服务和一个用户可见的activity，则此进程会被评定为可见进程，而不是服务进程。</p>
<p>此外，一个进程的级别可能会由于其它进程的依赖而被提高——为其它进程提供服务的进程级别永远不会低于使用此服务的进程。比如：如果A进程中的content provider为进程B中的客户端提供服务，或进程A中的服务被进程B中的组件所调用，则A进程至少被视为与进程B同样重要。</p>
<p>因为运行服务的进程级别是高于后台activity进程的，所以，如果activity需要启动一个长时间运行的操作，则为其启动一个服务会比简单地创建一个工作线程更好些——尤其是该操作时间比activity的生存期还要长的情况下。比如，一个activity要把图片上传至Web网站，就应该创建一个服务来执行之，即使用户离开了此activity，上传还是会在后台继续运行。不论activity发生什么情况，使用服务可以保证操作至少拥有“服务进程”的优先级。同理，广播接收器broadcast receiver也是使用服务来处理耗时任务的，而不是简单地把它放入线程中。</p>
<h2 id="u6740_u4E0D_u6B7B_u7684Service"><a href="#u6740_u4E0D_u6B7B_u7684Service" class="headerlink" title="杀不死的Service"></a>杀不死的Service</h2><p>如何让应用在手机中存活更长时间？网上各种方法可谓是千奇百怪，有些简直异想天开。</p>
<ul>
<li>系统广播唤醒应用，比如手机开机，网络切换等</li>
<li>接入第三方SDK唤醒应用，比如接入微信SDK会唤醒微信</li>
<li>免杀白名单，比如360免杀白名单，MIUI系统免杀白名单</li>
<li>全家桶，应用之间互相唤醒，比如百度系，阿里系应用</li>
<li>两个Service互相唤醒（这个就别想了，不靠谱）</li>
<li>使用Timer定时器（一样不靠谱）</li>
</ul>
<p>设计良好的应用不应该在用户不使用的时候依然保持运行。一直在后台运行不光费电费流量，还是造成系统卡顿的主要原因之一（参见上文分析）。正常的做法是优化你的应用程序，减少不合理场景的情况，除一些必要服务应用外，大部分应用不需要一直在后台保存运行状态。</p>
<p>有正常的做法就有不正常的做法，让应用长时间停留在用户手机中无外乎就是增加所谓的活跃用户数等一些产品指标。这对于很多公司还是很有吸引力的。</p>
<p>如上文所说，无论应用怎么挣扎，当处于不可见进程的情况下随时都有可能被杀死。所以使用前台进程是最有效的方法。但前台进程必须有一个Notifcation显示在通知栏中，有没有办法让应用以前台进程的方式启动同时又不显示Notifcation？方法当然有，就是利用系统漏洞：</p>
<ul>
<li>API&lt;18，启动前台Service时直接传入new Notifcation();</li>
<li>API&gt;=18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理</li>
</ul>
<p>目前，QQ，微信，支付宝等知名应用都使用此方案。不过如果应用占用太多内存即使是前台进程也依然会被干掉。</p>
<p>这些所谓的实现进程杀不死的方案并不都是一劳永逸的方法，以牺牲用户体验为代价很有可能会激怒用户卸载你的应用，所以最好的方式还是遵循Android规范开发性能更优更合理的应用程序。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理/">内存管理</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android内核剖析/">Android内核剖析</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Gooooood
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>